---
title: "Getting started with vcr"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with vcr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor:
  markdown:
    wrap: sentence
---

```{r echo=FALSE}
knitr::opts_chunk$set(
	comment = "#>",
	collapse = TRUE
)
```

{vcr} records and replays HTTP requests so you can test your API package with speed and confidence.
It makes your tests independent of your internet connection (so they work on CRAN!) and because your tests get much much faster, you can write even more, increasing the coverage of your package.
vcr works with {crul}, {httr}, and {httr2}.
This vignette will introduce you to the basics of vcr for testing.
To learn more about testing web requests in general, we recommend that you check out the [HTTP testing book](https://books.ropensci.org/http-testing/) which has a lot more documentation on all the packages involved.
Once you're familiar with vcr for testing, you'll also find it easy to use in vignettes and examples: see `setup_knitr()` and `insert_example_cassette()` for the details.

Here we'll use httr2 for generating the requests.
The same principles apply if you're working with crul or httr, just the code for making requests will look different.
I'm also going to start up a local httpbin server using webfakes.
This will let us make some requests to a server that we're running locally so we don't need to worry about the internet being down.

```{r setup}
library(vcr)
library(testthat)
library(httr2, warn.conflicts = FALSE)

httpbin <- webfakes::local_app_process(webfakes::httpbin_app())
```

```{r}
#| include: false
# Don't record any cassette for this vignette so they're always created afresh
vcr_configure(dir = tempdir())
```

## Getting started

The central metaphor of vcr is a video cassette.
This is what records your HTTP **interactions**, the pairs of HTTP request and response.
You **insert** a cassette to start the recording or begin the replay, and **eject** it when you're done.
To use vcr in a test, include a call to `vcr::local_cassette()`: it inserts the cassette and automatically ejects it when the test is done.

```{r}
#| label: get-record
test_that("my test", {
  vcr::local_cassette("get")
  
  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
  json <- resp_body_json(resp)

  expect_named(json, c("args", "headers", "origin", "path", "url"))
})
```

The first time you run the test it will record all request and responses in a **cassette**, a YAML file that lives in `test/testthat/_vcr`.
In future runs, it will replay those responses, freeing your test from the vagaries of the internet, making it both faster and more reliable.

It's important to ensure that every test has a uniquely named cassette.
Otherwise your tests will fail when they attempt to reload a request from the recording of a different test.

You can see exactly what vcr is doing with `local_vcr_configure_log()`.
This turns logging on so you can see each step in the recording and replaying process.
In this case, since it's the second run of the test, you can see that vcr loads the previously saved interaction then replays it.

```{r}
#| label: get-replay
test_that("my test", {
  vcr::local_vcr_configure_log(file = stdout())
  vcr::local_cassette("get")
  
  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
  json <- resp_body_json(resp)

  expect_named(json, c("args", "headers", "origin", "path", "url"))
})
```

You can learn more about logging and how to use it to debug cases where vcr behaves unexpectedly in `vignette("debugging")`.

## Cassette files

It's good practice to look at the cassette files that are saved to disk, for instance before committing them to Git or before merging a PR.
This will help you understand how vcr works by seeing exactly what data it uses.
Here's the cassette we created above:

```{r}
#| label: get-show
#| echo: false
#| output: asis

cat("```yaml\n")
writeLines(readLines(file.path(cassette_path(), "get.yml")))
cat("\n```")
```

You can see that it records all components of the response, along with the components of the request used for matching (which defaults to `method` and `uri`; more on that shortly).
The first time you use vcr with your package, it's a really good idea to closely look at this file to make sure that you aren't accidentally leaking any secrets.
Learn the details in `vignette("secrets")`.

Sometimes it also makes sense to manually edit the cassettes.
Manually editing is typically most useful when you're testing error handling code, because it allows you to create responses that would otherwise be hard to get the API to generate.

## Request matching

By default, vcr looks for matching requests using just the HTTP method and the URI.
If you need to match requests differently you can use `match_requests_on` parameter.
The most likely reason to change this is to also match on the request body.
You can do this in two ways: with `"body"` or with `"body_json"`.
If your API uses JSON (like most modern APIs) you should use the `body_json` request matcher: that will parse the body as JSON so you'll get more informative messages if a new request doesn't match a request saved in a cassette.

Here's a little example with logging turned on, so you can see exactly what's happening:

```{r}
#| label: body-record

get_data <- function(b = 1) {
  req <- request(httpbin$url("/post"))
  req <- req_body_json(req, list(x = 1, y = list(a = 1, b = b)))
  resp <- req_perform(req)

  resp_body_json(resp)
}

test_that("my test", {
  vcr::local_vcr_configure_log(file = stdout())
  vcr::local_cassette("body", match_requests_on = c("method", "uri", "body_json"))
  
  data <- get_data(b = 1)
  expect_named(data$json, c("x", "y"))
})
```

```{r}
#| label: body-replay
#| error: true

test_that("my test", {
  vcr::local_vcr_configure_log(file = stdout())
  vcr::local_cassette("body", match_requests_on = c("method", "uri", "body_json"))
  
  data <- get_data(b = 2)
  expect_named(data$json, c("x", "y"))
})
```

If you look at the log you'll note that we see exactly where the difference is in the json, even though it's buried several layers deep.
Compare this to just using `"body"`, where you have to carefully compare two strings.

```{r}
#| label: body-replay-raw
#| error: true

test_that("my test", {
  vcr::local_vcr_configure_log(file = stdout())
  vcr::local_cassette("body", match_requests_on = c("method", "uri", "body"))
  
  data <- get_data(b = 2)
  expect_named(data$json, c("x", "y"))
})
```
