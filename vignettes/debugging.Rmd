---
title: "Debugging your tests that use vcr"
date: "`r Sys.Date()`"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{4. vcr tests debugging}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
vcr::vcr_configure(dir = ".")
```

This vignette helps you debug the vcr error that you're most likely to encounter: "An HTTP request has been made that vcr does not know how to handle". If you're lucky the request has genuinely changed, and you can make this problem go away by deleting the previous cassette so vcr can re-record it ðŸ™‚. Otherwise, you'll need to do some debugging.

* The request has genuinely changed, and you need to re-record the cassette.
* A new request doesn't match the previous request and you need to figure out why.

Here we'll use httr2 for generating the requests. The same principles apply if you're working with crul or httr, just the code for making requests will look different. I'm also going to start up a local httpbin server using webfakes. This will let us make some requests to a server that we're running locally so we don't need to worry about the internet being down.

```{r setup}
library(vcr)
library(httr2)
httpbin <- webfakes::local_app_process(webfakes::httpbin_app())
httpbin$url()
```

## Logging basics

The best tool to understand why your request isn't match is vcr's logging. Here we'll introduce you to the basics, so you understand what's going on in simple cases. You can turn logging on for a single test with `local_vcr_configure_log()`. Normally that's all you need, but since we're inside a vignette here, we also need to set `file = stdout()`.

### The first request

Now lets look at what happens the first time you make a request:

```{r}
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
})
```

We can see a new cassettte gets inserted, and it will record new requests. Then it handles a request, recording it to disk. Finally the cassette is ejected.

### Second and subsequent requests

If we run that code another time, the flow is slightly different:

```{r}
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
})
```

It now loads the previous interactions from disk and it's no longer recording new requests. This time it matches the request to one that was saved earlier and replays the response.

### A match failure

We can now deliberately make a different request to see what happens. We'll leave everything the same but change the method to `POST`:

```{r}
#| error: true

local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get")) |> req_method("POST")
  resp <- req_perform(req)
})
```

This time you can see vcr didn't find any matches because there was only one request, and that request (`recorded`) had a different method to the request we were trying to match.

### Multiple requests

Before we move on to specific scenarios, lets look at a case where we record multiple requests:

```{r}
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-2")

  resp1 <- req_perform(request(httpbin$url("/get?x=1")))
  resp2 <- req_perform(request(httpbin$url("/get?x=2")))
  resp3 <- req_perform(request(httpbin$url("/get?x=3")))
})
```

Now if we deliberately change the url, you can see that it looks at all three previously saved requests before giving up.

```{r}
#| error: true
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-2")

  resp4 <- req_perform(request(httpbin$url("/get?x=4")))
})
```

```{r}
#| include: false
unlink("debugging-1.yml")
unlink("debugging-2.yml")
```
