---
title: "Debugging your tests that use vcr"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{4. vcr tests debugging}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
vcr::vcr_configure(dir = ".")
setHook("rmarkdown.onKnitCompleted", \(...) unlink(dir(pattern = "\\.yml$")))
```

This vignette helps you debug the vcr error that you're most likely to encounter: "An HTTP request has been made that vcr does not know how to handle". If you're lucky the request has genuinely changed, and you can make this problem go away by deleting the previous cassette so vcr can re-record it ðŸ™‚. Otherwise, you'll need to do some debugging. 

This vignette will teach you how to identify and resolve the most common issues you'll encounter with vcr. First we'll talk about logging, and how you can use it to better understand vcr's request matching process. Then we'll work through the most common problems and identify their solutions.

In this vignette, we'll use httr2 for generating the requests. The same principles apply if you're working with crul or httr, just the code for making requests will look different. We'll also start up a local httpbin server using {webfakes}: this will let us make some practice requests to a local server.

```{r setup}
library(vcr)
library(httr2)
httpbin <- webfakes::local_app_process(webfakes::httpbin_app())
httpbin$url()
```

```{r}
#| include: false

# Override default logging output so we don't need to explain the difference
# between logging in vignettes and tests, and the reader can just copy and 
# paste code
local_vcr_configure_log <- function(..., frame = parent.frame()) {
  vcr::local_vcr_configure_log(..., file = stdout(), frame = frame)
}
```

## Logging basics

The best tool to understand why your request isn't matching is logging. You can turn logging on for a single test with `local_vcr_configure_log()`. Now lets look at what happens the first time you make a request:

```{r}
local({
  local_vcr_configure_log()
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
})
```

We can see a new cassettte gets inserted with recording turned on. Then it handles a request, recording it to disk. Finally the cassette is ejected.

### Second and subsequent requests

If we run that code another time, the flow is slightly different:

```{r}
local({
  local_vcr_configure_log()
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
})
```

This time it loads one interaction from disk and it's no longer recording new requests. This time it matches the request to one that was saved earlier and replays the response.

### A match failure

We can now deliberately make a different request to see what happens. We'll leave everything the same but change the method to `POST`:

```{r}
#| error: true
local({
  local_vcr_configure_log()
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get")) |> req_method("POST")
  resp <- req_perform(req)
})
```

This time you can see vcr didn't find any matches because there was only one request, and that request (`recorded`) had a different method to the request we were trying to match.

What happens if change the URL?

```{r}
#| error: true
local({
  local_vcr_configure_log()
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get?x=1"))
  resp <- req_perform(req)
})
```

Again, you can see why the request didn't match. vcr uses {waldo} to generate diffs, that hopefully make it easy to see what's different.

### Multiple requests

Before we move on to specific scenarios, lets look at a case where we record multiple requests:

```{r}
local({
  local_vcr_configure_log()
  local_cassette("debugging-2")

  resp1 <- req_perform(request(httpbin$url("/get?x=1")))
  resp2 <- req_perform(request(httpbin$url("/get?x=2")))
  resp3 <- req_perform(request(httpbin$url("/get?x=3")))
})
```

Now if we deliberately change the url, you can see that it looks at all three previously saved requests before giving up.

```{r}
#| error: true
local({
  local_vcr_configure_log()
  local_cassette("debugging-2")

  resp4 <- req_perform(request(httpbin$url("/get?x=4")))
})
```

You'll notice that this is substantially more complicated to understand, and you can imagine it only gets harder the more requests you have. That's a good reason to keep your tests small and simple, and limited to only a couple of requests.

## Solutions

Now that you understand how to use logging to see exactly what vcr is doing, we can talk about some solutions to common problems.

### Re-used cassette name

You need to make sure that every test has it's own unique cassette name, otherwise you won't find the responses that you're expecting. This is generally a fairly easy problem to diagnose if you're aware of it: if you re-record the cassette to fix the test you're currently in, a different test will break.

### Replaying requests

What happens if you make the same request multiple times in a single cassette?

```{r}
local({
  local_cassette("debugging-3")

  resp1 <- req_perform(request(httpbin$url("/get")))
  resp2 <- req_perform(request(httpbin$url("/get")))
})
```

On replay, the second request will fail because by default, vcr does not allow you to replay the same request multiple times:

```{r}
#| error: true
local({
  local_vcr_configure_log()
  local_cassette("debugging-3")

  resp1 <- req_perform(request(httpbin$url("/get")))
  resp2 <- req_perform(request(httpbin$url("/get")))
})
```

You can resolve that problem by setting `allow_playback_repeats = TRUE`;
```{r}
#| error: true
local({
  local_vcr_configure_log()
  local_cassette("debugging-3", allow_playback_repeats = TRUE)

  resp1 <- req_perform(request(httpbin$url("/get")))
  resp2 <- req_perform(request(httpbin$url("/get")))
})
```

### Non-determinstic requests

Sometimes it's not possible to make the same request again and again. For example, in some cases an API will require a "nonce", a random string used to ensure that every request is unique:

```{r}
#| error: true
make_request <- function() {
  nonce <- paste0(sample(letters, 10, replace = TRUE), collapse = "")

  req <- request(httpbin$url("/get")) 
  req <- req_url_query(req, nonce = nonce)
  req_perform(req)
}

local({ 
  local_cassette("nondeterministic")
  
  resp <- make_request()
})

local({ 
  local_vcr_configure_log()
  local_cassette("nondeterministic")
  
  resp <- make_request()
})
```

You can solve this problem by trimming that component from the query string using the `filter_query_parameters` option. This will remove the specific query parameter names from the uri being matched.

```{r}
local({ 
  local_vcr_configure_log()
  local_vcr_configure(filter_query_parameters = "nonce")
  local_cassette("nondeterministic")
  
  resp <- make_request()
})
```

In the less common case where you're matching on headers, you can use the `filter_request_headers` configuration to achieve the same effect.
