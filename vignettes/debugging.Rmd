---
title: "Debugging your tests that use vcr"
date: "`r Sys.Date()`"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{4. vcr tests debugging}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
vcr::vcr_configure(dir = ".")

setHook("rmarkdown.onKnitCompleted", \(...) unlink(dir(pattern = "\\.yml$")))
```

This vignette helps you debug the vcr error that you're most likely to encounter: "An HTTP request has been made that vcr does not know how to handle". If you're lucky the request has genuinely changed, and you can make this problem go away by deleting the previous cassette so vcr can re-record it ðŸ™‚. Otherwise, you'll need to do some debugging.

* The request has genuinely changed, and you need to re-record the cassette.
* A new request doesn't match the previous request and you need to figure out why.

Here we'll use httr2 for generating the requests. The same principles apply if you're working with crul or httr, just the code for making requests will look different. I'm also going to start up a local httpbin server using webfakes. This will let us make some requests to a server that we're running locally so we don't need to worry about the internet being down.

```{r setup}
library(vcr)
library(httr2)
httpbin <- webfakes::local_app_process(webfakes::httpbin_app())
httpbin$url()
```

## Logging basics

The best tool to understand why your request isn't match is vcr's logging. Here we'll introduce you to the basics, so you understand what's going on in simple cases. You can turn logging on for a single test with `local_vcr_configure_log()`. Normally that's all you need, but since we're inside a vignette here, we also need to set `file = stdout()`.

### The first request

Now lets look at what happens the first time you make a request:

```{r}
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
})
```

We can see a new cassettte gets inserted, and it will record new requests. Then it handles a request, recording it to disk. Finally the cassette is ejected.

### Second and subsequent requests

If we run that code another time, the flow is slightly different:

```{r}
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get"))
  resp <- req_perform(req)
})
```

It now loads the previous interactions from disk and it's no longer recording new requests. This time it matches the request to one that was saved earlier and replays the response.

### A match failure

We can now deliberately make a different request to see what happens. We'll leave everything the same but change the method to `POST`:

```{r}
#| error: true

local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-1")

  req <- request(httpbin$url("/get")) |> req_method("POST")
  resp <- req_perform(req)
})
```

This time you can see vcr didn't find any matches because there was only one request, and that request (`recorded`) had a different method to the request we were trying to match.

### Multiple requests

Before we move on to specific scenarios, lets look at a case where we record multiple requests:

```{r}
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-2")

  resp1 <- req_perform(request(httpbin$url("/get?x=1")))
  resp2 <- req_perform(request(httpbin$url("/get?x=2")))
  resp3 <- req_perform(request(httpbin$url("/get?x=3")))
})
```

Now if we deliberately change the url, you can see that it looks at all three previously saved requests before giving up.

```{r}
#| error: true
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-2")

  resp4 <- req_perform(request(httpbin$url("/get?x=4")))
})
```

You'll notice that this is substantially more complicated to understand, and you can imagine it only gets harder the more requests you have. That's a good reason to keep your tests small and simple, and limited to only a couple of requests.

## Solutions

Now that you understand how to use logging to see exactly what vcr is doing, we can talk about some solutions to common problems.

### Replaying requests

What happens if you make the same request multiple times in a single cassette?

```{r}
local({
  local_cassette("debugging-3")

  resp1 <- req_perform(request(httpbin$url("/get")))
  resp2 <- req_perform(request(httpbin$url("/get")))
})
```

On replay, the second request will fail because my default, vcr does not allow you to replay the same request multiple times:

```{r}
#| error: true
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-3")

  resp1 <- req_perform(request(httpbin$url("/get")))
  resp2 <- req_perform(request(httpbin$url("/get")))
})
```

You can resolve that problem by setting `allow_playback_repeats = TRUE`;
```{r}
#| error: true
local({
  local_vcr_configure_log(file = stdout())
  local_cassette("debugging-3", allow_playback_repeats = TRUE)

  resp1 <- req_perform(request(httpbin$url("/get")))
  resp2 <- req_perform(request(httpbin$url("/get")))
})
```

### Non-determinstic requests

Sometimes it's not possible to make the same request again and again. For example, in some cases an API will require a "nonce", a random string used to ensure that every request is unique:

```{r}
#| error: true
make_request <- function() {
  nonce <- paste0(sample(letters, 10, replace = TRUE), collapse = "")

  req <- request(httpbin$url("/get")) 
  req <- req_url_query(req, nonce = nonce)
  req_perform(req)
}

local({ 
  local_cassette("nondeterministic")
  
  resp <- make_request()
})

local({ 
  local_vcr_configure_log(file = stdout())
  local_cassette("nondeterministic")
  
  resp <- make_request()
})
```

You can solve this problem by trimming that component from the query string using the `filter_query_parameters` option. This will remove the specific query parameter names from the uri being matched.

```{r}
local({ 
  local_vcr_configure_log(file = stdout())
  local_vcr_configure(filter_query_parameters = "nonce")
  local_cassette("nondeterministic")
  
  resp <- make_request()
})
```

In the less common case where you're matching on headers, you can use the `filter_request_headers` configuration to achieve the same effect.

