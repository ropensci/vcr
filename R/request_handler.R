#' @title RequestHandler
#' @description Base handler for http requests, deciding whether a
#' request is stubbed, to be ignored, recordable, or unhandled
#' @export
#' @details
#' \strong{Private Methods}
#'   \describe{
#'     \item{\code{externally_stubbed()}}{
#'       just returns FALSE
#'     }
#'     \item{\code{get_stubbed_response()}}{
#'       Check for a response and get it
#'     }
#'     \item{\code{request_summary(request)}}{
#'       get a request summary
#'     }
#'     \item{\code{on_externally_stubbed_request(request)}}{
#'       on externally stubbed request do nothing
#'     }
#'     \item{\code{on_ignored_request(request)}}{
#'       on ignored request, do something
#'     }
#'     \item{\code{on_recordable_request(request)}}{
#'       on recordable request, record the request
#'     }
#'     \item{\code{on_unhandled_request(request)}}{
#'       on unhandled request, run UnhandledHTTPRequestError
#'     }
#'   }
RequestHandler <- R6::R6Class(
  'RequestHandler',
  public = list(
    #' @field request_original Request, as generated by the HTTP package.
    request_original = NULL,
    #' @field request Request, as used by vcr.
    request = NULL,

    #' @description Handle the request (`request` given in `$initialize()`)
    #' @return handles a request, outcomes vary
    handle = function() {
      vcr_log_sprintf(
        "Handling request: %s",
        private$request_summary(self$request)
      )

      if (private$externally_stubbed()) {
        # FIXME: not quite sure what externally_stubbed is meant for
        #   perhaps we can get rid of it here if only applicable in Ruby
        vcr_log_sprintf("- externally stubbed")
        private$on_externally_stubbed_request()
      } else if (should_be_ignored(self$request)) {
        vcr_log_sprintf("- ignored")
        private$on_ignored_request()
      } else if (cassette_has_response(self$request)) {
        vcr_log_sprintf("- stubbed by vcr")
        private$on_stubbed_by_vcr_request()
      } else if (cassette_is_recording()) {
        vcr_log_sprintf("- recordable")
        private$on_recordable_request()
      } else {
        vcr_log_sprintf("- unhandled")
        private$on_unhandled_request()
      }
    }
  ),

  private = list(
    request_summary = function(request) {
      request_matchers <- current_cassette()$match_requests_on
      request_summary(request, request_matchers)
    },

    # request type helpers
    externally_stubbed = function() FALSE,

    get_stubbed_response = function(request) {
      if (!cassette_active()) {
        return(NULL)
      }
      interactions <- current_cassette()$http_interactions
      interactions$response_for(request)
    },

    #####################################################################
    ### various on* methods, some global for any adapter,
    ###   and some may be specific to an adapter
    ###   - all fxns take `request` param for consistentcy, even if they dont use it
    ##### so we can "monkey patch" these in each HTTP client adapter by
    #####   reassigning some of these functions with ones specific to the HTTP client

    on_externally_stubbed_request = function() NULL,

    on_ignored_request = function() {
      # perform and return REAL http response
      # reassign per adapter
    },
    on_stubbed_by_vcr_request = function() {
      # return stubbed vcr response - no real response to do
      # reassign per adapter
    },
    on_recordable_request = function() {
      # do real request - then stub response - then return stubbed vcr response
      # - this may need to be called from webmockr cruladapter?
      # reassign per adapter
    },
    on_unhandled_request = function() {
      err <- UnhandledHTTPRequestError$new(self$request)
      err$run()
    }
  )
)

cassette_is_recording <- function() {
  if (cassette_active()) {
    current_cassette()$recording()
  } else {
    FALSE
  }
}

cassette_has_response <- function(request) {
  if (cassette_active()) {
    interactions <- current_cassette()$http_interactions
    interactions$has_interaction(request)
  } else {
    FALSE
  }
}
